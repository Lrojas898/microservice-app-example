name: Production Deployment Pipeline

on:
  push:
    branches: [master]
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

env:
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  # Variables de entorno para Terraform con backend azurerm
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

jobs:
  # Job para validar cÃ³digo antes del despliegue
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            }

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Terraform Format Check
        run: terraform fmt -check -recursive
        working-directory: ./terraform

      - name: Terraform Init
        run: |
          echo "ğŸ”‘ Initializing Terraform with remote backend for validation..."
          terraform init -upgrade
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Validate
        run: terraform validate
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

  # Job para construir imÃ¡genes Docker para producciÃ³n
  build-production-images:
    name: Build Production Images
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: pre-deployment-checks
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Generate unique image tag
        id: tag
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            TAG="latest"
          else
            TAG="gh-${GITHUB_SHA::8}"
          fi
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Generated tag: $TAG"

      # Set up JDK 8 for Java projects
      - name: Set up JDK 8
        uses: actions/setup-java@v3
        with:
          java-version: "8"
          distribution: "temurin"

      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('users-api/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      # Build users-api (Java/Spring Boot)
      - name: Build users-api
        run: |
          cd ./users-api
          mvn clean package -DskipTests
          cd ..
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/users-service:$TAG ./users-api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/users-service:$TAG

      # Build auth-api (Go)
      - name: Build auth-api
        run: |
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/auth-service:$TAG ./auth-api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/auth-service:$TAG

      # Build todos-api (Node.js)
      - name: Build todos-api
        run: |
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/todos-service:$TAG ./todos-api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/todos-service:$TAG

      # Build frontend (Vue.js) - using pre-built folder
      - name: Build frontend
        run: |
          echo "âš ï¸ Using pre-built 'build' folder from repo"
          if [ ! -d "frontend/build" ]; then
            echo "âŒ Pre-built folder 'build' not found in ./frontend/"
            ls -la frontend/
            exit 1
          fi
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$TAG ./frontend
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$TAG

      # Build log-message-processor (Python)
      - name: Build log-message-processor
        run: |
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:$TAG ./log-message-processor
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:$TAG

  # Job para desplegar infraestructura de producciÃ³n
  deploy-infrastructure:
    name: Deploy Production Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: [pre-deployment-checks, build-production-images]
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            }

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Terraform Init
        run: |
          echo "ğŸ”‘ Initializing Terraform with remote backend..."
          terraform init -upgrade
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Import Existing Resources (Comprehensive)
        run: |
          echo "ğŸ“¥ Comprehensive import of ALL existing Azure resources..."
          TAG=${{ needs.build-production-images.outputs.image_tag }}

          # Set variables for import commands
          export TF_VAR_location="chilecentral"
          export TF_VAR_resource_group_location="chilecentral"
          export TF_VAR_db_location="chilecentral"
          export TF_VAR_subscriptionId="${{ env.AZURE_SUBSCRIPTION_ID }}"
          export TF_VAR_client_id="${{ env.AZURE_CLIENT_ID }}"
          export TF_VAR_client_secret="${{ env.AZURE_CLIENT_SECRET }}"
          export TF_VAR_tenant_id="${{ env.AZURE_TENANT_ID }}"
          export TF_VAR_dockerhub_username="${{ secrets.DOCKERHUB_USERNAME }}"
          export TF_VAR_dockerhub_token="${{ secrets.DOCKERHUB_TOKEN }}"
          export TF_VAR_users_api_image="${{ secrets.DOCKERHUB_USERNAME }}/users-service:${TAG}"
          export TF_VAR_auth_api_image="${{ secrets.DOCKERHUB_USERNAME }}/auth-service:${TAG}"
          export TF_VAR_todos_api_image="${{ secrets.DOCKERHUB_USERNAME }}/todos-service:${TAG}"
          export TF_VAR_frontend_image="${{ secrets.DOCKERHUB_USERNAME }}/frontend:${TAG}"
          export TF_VAR_log_processor_image="${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:${TAG}"

          # Get or set unique suffix
          UNIQUE_SUFFIX=$(terraform output -raw unique_suffix 2>/dev/null || echo "momz603w")
          echo "ğŸ”‘ Using unique suffix: $UNIQUE_SUFFIX"

          # Function to ALWAYS try import with proper error handling
          force_import_always() {
            local resource_name="$1"
            local resource_id="$2"
            echo "ğŸ“¦ FORCE importing $resource_name (always attempt)..."

            # ALWAYS try to import, regardless of current state
            if terraform import "$resource_name" "$resource_id" 2>/dev/null; then
              echo "âœ… Successfully imported $resource_name"
              return 0
            else
              # Check if it's already in state (which is OK)
              if terraform state show "$resource_name" >/dev/null 2>&1; then
                echo "âœ“ $resource_name already in state (import failed but resource exists)"
                return 0
              else
                echo "âš ï¸ Import failed and $resource_name not in state"
                return 1
              fi
            fi
          }

          echo "ğŸš€ Starting comprehensive resource import..."

          # 1. ALWAYS import Resource Group (must be first)
          force_import_always "azurerm_resource_group.main" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg"

          # 2. Random string (cannot be imported, but should be in state)
          echo "ğŸ“¦ Checking random_string.unique..."
          terraform state show "random_string.unique" >/dev/null 2>&1 || echo "âš ï¸ random_string.unique not in state"

          # 3. ALWAYS import Network resources
          force_import_always "module.network.azurerm_virtual_network.main" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Network/virtualNetworks/microservice-vnet"
          force_import_always "module.network.azurerm_subnet.auth" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Network/virtualNetworks/microservice-vnet/subnets/auth-db-subnet"
          force_import_always "module.network.azurerm_subnet.users" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Network/virtualNetworks/microservice-vnet/subnets/users-db-subnet"
          force_import_always "module.network.azurerm_subnet.todos" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Network/virtualNetworks/microservice-vnet/subnets/todos-db-subnet"
          force_import_always "module.network.azurerm_subnet.cache" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Network/virtualNetworks/microservice-vnet/subnets/cache-subnet"

          # 4. ALWAYS import Redis Cache resources
          force_import_always "module.security.azurerm_redis_cache.main" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Cache/Redis/microservice-redis-optimized-${UNIQUE_SUFFIX}"
          force_import_always "module.security.azurerm_redis_firewall_rule.allow_all" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Cache/Redis/microservice-redis-optimized-${UNIQUE_SUFFIX}/firewallRules/allow_all_ips"

          # 5. ALWAYS import PostgreSQL resources
          force_import_always "azurerm_postgresql_flexible_server.consolidated" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}"
          force_import_always "azurerm_postgresql_flexible_server_database.auth_db" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}/databases/authdb"
          force_import_always "azurerm_postgresql_flexible_server_database.users_db" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}/databases/usersdb"
          force_import_always "azurerm_postgresql_flexible_server_database.todos_db" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}/databases/todosdb"

          # 6. ALWAYS import ALL Container Groups (no conditions, no skipping)
          echo "ğŸ”„ FORCE importing ALL Container Groups - NO SKIPPING..."
          declare -A containers=(
            ["zipkin"]="zipkin-service"
            ["auth"]="auth-service"
            ["users"]="users-service"
            ["todos"]="todos-service"
            ["log_processor"]="log-processor-service"
            ["frontend"]="frontend-service"
          )

          for resource_key in "${!containers[@]}"; do
            container_name="${containers[$resource_key]}"
            resource_id="/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.ContainerInstance/containerGroups/$container_name"

            echo "ğŸ¯ FORCE importing azurerm_container_group.$resource_key (ALWAYS attempt)..."

            # ALWAYS attempt import - no checking if already in state
            import_success=false
            for attempt in 1 2 3 4 5 6 7 8 9 10; do
              echo "ğŸ”„ FORCE import attempt $attempt/10 for azurerm_container_group.$resource_key..."

              if terraform import "azurerm_container_group.$resource_key" "$resource_id" 2>/dev/null; then
                echo "âœ… Successfully FORCE imported azurerm_container_group.$resource_key on attempt $attempt"
                import_success=true
                break
              else
                echo "âš ï¸ FORCE import attempt $attempt failed"
                # Check if it's in state anyway (import may fail if already imported)
                if terraform state show "azurerm_container_group.$resource_key" >/dev/null 2>&1; then
                  echo "âœ“ azurerm_container_group.$resource_key is in state despite import failure"
                  import_success=true
                  break
                fi

                if [[ $attempt -lt 10 ]]; then
                  echo "ğŸ•’ Waiting 2 seconds before retry..."
                  sleep 2
                fi
              fi
            done

            if [[ "$import_success" == "false" ]]; then
              echo "âŒ CRITICAL: Failed to import azurerm_container_group.$resource_key after 10 attempts"
            else
              echo "âœ… azurerm_container_group.$resource_key successfully handled"
            fi
          done

          # 7. ALWAYS import Logic App Workflow
          force_import_always "azurerm_logic_app_workflow.log_processor" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Logic/workflows/log_processor"

          echo "âœ… Comprehensive import completed!"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Comprehensive State Verification
        run: |
          echo "ğŸ” Comprehensive Terraform state verification..."

          echo "ğŸ“‹ All resources currently in state:"
          terraform state list | sort

          echo ""
          echo "ğŸ¯ Detailed resource verification:"

          # Function to check resource in state
          check_resource() {
            local resource_name="$1"
            if terraform state show "$resource_name" >/dev/null 2>&1; then
              echo "âœ… $resource_name is in state"
              return 0
            else
              echo "âŒ $resource_name is NOT in state"
              return 1
            fi
          }

          missing_resources=0

          # Core infrastructure
          check_resource "azurerm_resource_group.main" || ((missing_resources++))
          check_resource "random_string.unique" || ((missing_resources++))

          # Network resources
          check_resource "module.network.azurerm_virtual_network.main" || ((missing_resources++))
          check_resource "module.network.azurerm_subnet.auth" || ((missing_resources++))
          check_resource "module.network.azurerm_subnet.users" || ((missing_resources++))
          check_resource "module.network.azurerm_subnet.todos" || ((missing_resources++))
          check_resource "module.network.azurerm_subnet.cache" || ((missing_resources++))

          # Redis resources
          check_resource "module.security.azurerm_redis_cache.main" || ((missing_resources++))

          # Database resources
          check_resource "azurerm_postgresql_flexible_server.consolidated" || ((missing_resources++))
          check_resource "azurerm_postgresql_flexible_server_database.auth_db" || ((missing_resources++))
          check_resource "azurerm_postgresql_flexible_server_database.users_db" || ((missing_resources++))
          check_resource "azurerm_postgresql_flexible_server_database.todos_db" || ((missing_resources++))

          # Container Groups (critical for error message)
          for resource in zipkin auth users todos log_processor frontend; do
            check_resource "azurerm_container_group.$resource" || ((missing_resources++))
          done

          echo ""
          echo "ğŸ“Š State verification summary:"
          echo "Total resources in state: $(terraform state list | wc -l)"
          echo "Missing critical resources: $missing_resources"

          if [[ $missing_resources -gt 0 ]]; then
            echo "âš ï¸ WARNING: $missing_resources critical resources are missing from state"
            echo "This may cause 'resource already exists' errors during apply"
          else
            echo "âœ… All critical resources are properly tracked in state"
          fi

          echo "âœ… State verification completed!"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Final State Verification Before Plan
        run: |
          echo "ğŸ” Final state verification before terraform plan..."

          echo "ğŸ“‹ Complete resource list in state:"
          terraform state list | sort

          echo ""
          echo "ğŸ¯ Container Groups verification:"
          all_containers_present=true

          for resource in zipkin auth users todos log_processor frontend; do
            if terraform state show "azurerm_container_group.$resource" >/dev/null 2>&1; then
              echo "âœ… azurerm_container_group.$resource is in state"
            else
              echo "âŒ azurerm_container_group.$resource is STILL NOT in state"
              all_containers_present=false
            fi
          done

          echo ""
          if [[ "$all_containers_present" == "true" ]]; then
            echo "âœ… SUCCESS: All container groups are now in terraform state"
            echo "The apply should proceed without 'resource already exists' errors"
          else
            echo "âŒ WARNING: Some container groups are still missing from state"
            echo "This may still cause 'resource already exists' errors during apply"
          fi

          echo "ğŸ“Š Total resources in state: $(terraform state list | wc -l)"
          echo "âœ… Final verification completed!"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Force Unlock Terraform State
        continue-on-error: true
        run: |
          echo "ğŸ”“ Attempting to unlock Terraform state..."
          # Try to force unlock using a known lock ID pattern
          terraform force-unlock -force 6f82c0a9-c0fe-881e-7792-0eaab46f44cf 2>/dev/null || echo "âœ“ No lock to unlock or already unlocked"

          # Alternative: Try to identify any existing locks and unlock them
          echo "ğŸ” Checking for any existing locks..."
          terraform plan -lock=false -input=false -out=/dev/null 2>/dev/null || echo "âœ“ State appears to be accessible"

          echo "âœ… State unlock process completed"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Plan
        id: plan
        run: |
          echo "ğŸ“‹ Generating execution plan..."
          TAG=${{ needs.build-production-images.outputs.image_tag }}

          # Retry mechanism for plan in case of lock issues
          for attempt in 1 2 3; do
            echo "ğŸ”„ Plan attempt $attempt/3..."
            if terraform plan \
              -var="location=chilecentral" \
              -var="resource_group_location=chilecentral" \
              -var="db_location=chilecentral" \
              -var="subscriptionId=${{ env.AZURE_SUBSCRIPTION_ID }}" \
              -var="client_id=${{ env.AZURE_CLIENT_ID }}" \
              -var="client_secret=${{ env.AZURE_CLIENT_SECRET }}" \
              -var="tenant_id=${{ env.AZURE_TENANT_ID }}" \
              -var="dockerhub_username=${{ secrets.DOCKERHUB_USERNAME }}" \
              -var="dockerhub_token=${{ secrets.DOCKERHUB_TOKEN }}" \
              -var="users_api_image=${{ secrets.DOCKERHUB_USERNAME }}/users-service:${TAG}" \
              -var="auth_api_image=${{ secrets.DOCKERHUB_USERNAME }}/auth-service:${TAG}" \
              -var="todos_api_image=${{ secrets.DOCKERHUB_USERNAME }}/todos-service:${TAG}" \
              -var="frontend_image=${{ secrets.DOCKERHUB_USERNAME }}/frontend:${TAG}" \
              -var="log_processor_image=${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:${TAG}" \
              -out=tfplan; then
              echo "âœ… Plan completed successfully"
              break
            else
              echo "âš ï¸ Plan attempt $attempt failed"
              if [[ $attempt -lt 3 ]]; then
                echo "ğŸ”“ Attempting to unlock state before retry..."
                terraform force-unlock -force 6f82c0a9-c0fe-881e-7792-0eaab46f44cf 2>/dev/null || true
                sleep 10
              else
                echo "âŒ All plan attempts failed"
                exit 1
              fi
            fi
          done
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Show Plan (for review)
        run: |
          echo "ğŸ” PLAN PREVIEW:"
          terraform show tfplan
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Apply
        if: steps.plan.outcome == 'success' && github.ref == 'refs/heads/master'
        run: |
          echo "ğŸš€ Applying infrastructure changes..."
          terraform apply -input=false -auto-approve tfplan
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Verify State Consistency
        run: |
          echo "ğŸ” Verifying Terraform state consistency..."
          terraform state list
          echo "âœ… Terraform state is consistent and up to date!"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Emergency State Unlock
        if: failure()
        continue-on-error: true
        run: |
          echo "ğŸš¨ Emergency unlock due to job failure..."
          # Force unlock with all known patterns
          terraform force-unlock -force 6f82c0a9-c0fe-881e-7792-0eaab46f44cf 2>/dev/null || true
          # Try other common lock IDs if they exist
          echo "âœ… Emergency unlock completed"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Cleanup
        if: always()
        run: rm -f tfplan
        working-directory: ./terraform

  # Job para notificaciones
  notify-deployment:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [build-production-images, deploy-infrastructure]
    if: always()

    steps:
      - name: Notify Success
        if: needs.deploy-infrastructure.result == 'success'
        run: |
          TAG=${{ needs.build-production-images.outputs.image_tag }}
          echo "âœ… Production deployment completed successfully!"
          echo "ğŸš€ Services are now running in production"
          echo "ğŸ”— Images deployed with tag: $TAG"
          echo "ğŸ”— Users API: ${{ secrets.DOCKERHUB_USERNAME }}/users-service:$TAG"
          echo "ğŸ”— Auth API: ${{ secrets.DOCKERHUB_USERNAME }}/auth-service:$TAG"
          echo "ğŸ”— Todos API: ${{ secrets.DOCKERHUB_USERNAME }}/todos-service:$TAG"
          echo "ğŸ”— Frontend: ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$TAG"
          echo "ğŸ”— Log Processor: ${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:$TAG"
          echo "ğŸ“ Terraform state is synchronized and up to date"

      - name: Notify Failure
        if: needs.deploy-infrastructure.result == 'failure'
        run: |
          echo "âŒ Production deployment failed!"
          echo "ğŸ” Check the logs for more details"
          exit 1
