name: Production Deployment Pipeline

on:
  push:
    branches: [master]
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

env:
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  # Variables de entorno para Terraform con backend azurerm
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

jobs:
  # Job para validar código antes del despliegue
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            }

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Terraform Format Check
        run: terraform fmt -check -recursive
        working-directory: ./terraform

      - name: Terraform Init
        run: |
          echo "🔑 Initializing Terraform with remote backend for validation..."
          terraform init -upgrade
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Validate
        run: terraform validate
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

  # Job para construir imágenes Docker para producción
  build-production-images:
    name: Build Production Images
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: pre-deployment-checks
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Generate unique image tag
        id: tag
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            TAG="latest"
          else
            TAG="gh-${GITHUB_SHA::8}"
          fi
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT
          echo "📦 Generated tag: $TAG"

      # Set up JDK 8 for Java projects
      - name: Set up JDK 8
        uses: actions/setup-java@v3
        with:
          java-version: "8"
          distribution: "temurin"

      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('users-api/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      # Build users-api (Java/Spring Boot)
      - name: Build users-api
        run: |
          cd ./users-api
          mvn clean package -DskipTests
          cd ..
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/users-service:$TAG ./users-api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/users-service:$TAG

      # Build auth-api (Go)
      - name: Build auth-api
        run: |
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/auth-service:$TAG ./auth-api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/auth-service:$TAG

      # Build todos-api (Node.js)
      - name: Build todos-api
        run: |
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/todos-service:$TAG ./todos-api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/todos-service:$TAG

      # Build frontend (Vue.js) - using pre-built folder
      - name: Build frontend
        run: |
          echo "⚠️ Using pre-built 'build' folder from repo"
          if [ ! -d "frontend/build" ]; then
            echo "❌ Pre-built folder 'build' not found in ./frontend/"
            ls -la frontend/
            exit 1
          fi
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$TAG ./frontend
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$TAG

      # Build log-message-processor (Python)
      - name: Build log-message-processor
        run: |
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:$TAG ./log-message-processor
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:$TAG

  # Job para desplegar infraestructura de producción
  deploy-infrastructure:
    name: Deploy Production Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: [pre-deployment-checks, build-production-images]
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            }

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Terraform Init
        run: |
          echo "🔑 Initializing Terraform with remote backend..."
          terraform init -upgrade
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Import Existing Resources (Sync State)
        continue-on-error: true
        run: |
          echo "📥 Syncing Terraform state with existing Azure resources..."
          TAG=${{ needs.build-production-images.outputs.image_tag }}
          
          # Set variables for import commands
          export TF_VAR_location="chilecentral"
          export TF_VAR_resource_group_location="chilecentral"
          export TF_VAR_db_location="chilecentral"
          export TF_VAR_subscriptionId="${{ env.AZURE_SUBSCRIPTION_ID }}"
          export TF_VAR_client_id="${{ env.AZURE_CLIENT_ID }}"
          export TF_VAR_client_secret="${{ env.AZURE_CLIENT_SECRET }}"
          export TF_VAR_tenant_id="${{ env.AZURE_TENANT_ID }}"
          export TF_VAR_dockerhub_username="${{ secrets.DOCKERHUB_USERNAME }}"
          export TF_VAR_dockerhub_token="${{ secrets.DOCKERHUB_TOKEN }}"
          export TF_VAR_users_api_image="${{ secrets.DOCKERHUB_USERNAME }}/users-service:${TAG}"
          export TF_VAR_auth_api_image="${{ secrets.DOCKERHUB_USERNAME }}/auth-service:${TAG}"
          export TF_VAR_todos_api_image="${{ secrets.DOCKERHUB_USERNAME }}/todos-service:${TAG}"
          export TF_VAR_frontend_image="${{ secrets.DOCKERHUB_USERNAME }}/frontend:${TAG}"
          export TF_VAR_log_processor_image="${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:${TAG}"
          
          # Try to import each resource (will fail silently if already imported)
          echo "📦 Importing zipkin-service..."
          terraform import azurerm_container_group.zipkin "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.ContainerInstance/containerGroups/zipkin-service" 2>/dev/null || echo "✓ zipkin-service already managed or doesn't exist"

          echo "📦 Importing users-service..."
          terraform import azurerm_container_group.users "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.ContainerInstance/containerGroups/users-service" 2>/dev/null || echo "✓ users-service already managed or doesn't exist"

          echo "📦 Importing todos-service..."
          terraform import azurerm_container_group.todos "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.ContainerInstance/containerGroups/todos-service" 2>/dev/null || echo "✓ todos-service already managed or doesn't exist"

          echo "📦 Importing log-processor-service..."
          terraform import azurerm_container_group.log_processor "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.ContainerInstance/containerGroups/log-processor-service" 2>/dev/null || echo "✓ log-processor-service already managed or doesn't exist"

          echo "📦 Importing auth-service..."
          terraform import azurerm_container_group.auth "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.ContainerInstance/containerGroups/auth-service" 2>/dev/null || echo "✓ auth-service already managed or doesn't exist"

          echo "📦 Importing frontend-service..."
          terraform import azurerm_container_group.frontend "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.ContainerInstance/containerGroups/frontend-service" 2>/dev/null || echo "✓ frontend-service already managed or doesn't exist"

          # Import database and network resources if they exist
          echo "📦 Importing PostgreSQL server..."
          # Get unique suffix from terraform state or generate new one
          UNIQUE_SUFFIX=$(terraform output -raw unique_suffix 2>/dev/null || echo "momz603w")
          terraform import azurerm_postgresql_flexible_server.consolidated "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}" 2>/dev/null || echo "✓ PostgreSQL server already managed or doesn't exist"
          
          echo "✅ State synchronization completed - Terraform state is now up to date!"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Force Unlock Terraform State
        continue-on-error: true
        run: |
          echo "🔓 Attempting to unlock Terraform state..."
          # Try to force unlock using a known lock ID pattern
          terraform force-unlock -force 6f82c0a9-c0fe-881e-7792-0eaab46f44cf 2>/dev/null || echo "✓ No lock to unlock or already unlocked"

          # Alternative: Try to identify any existing locks and unlock them
          echo "🔍 Checking for any existing locks..."
          terraform plan -lock=false -input=false -out=/dev/null 2>/dev/null || echo "✓ State appears to be accessible"

          echo "✅ State unlock process completed"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Plan
        id: plan
        run: |
          echo "📋 Generating execution plan..."
          TAG=${{ needs.build-production-images.outputs.image_tag }}

          # Retry mechanism for plan in case of lock issues
          for attempt in 1 2 3; do
            echo "🔄 Plan attempt $attempt/3..."
            if terraform plan \
              -var="location=chilecentral" \
              -var="resource_group_location=chilecentral" \
              -var="db_location=chilecentral" \
              -var="subscriptionId=${{ env.AZURE_SUBSCRIPTION_ID }}" \
              -var="client_id=${{ env.AZURE_CLIENT_ID }}" \
              -var="client_secret=${{ env.AZURE_CLIENT_SECRET }}" \
              -var="tenant_id=${{ env.AZURE_TENANT_ID }}" \
              -var="dockerhub_username=${{ secrets.DOCKERHUB_USERNAME }}" \
              -var="dockerhub_token=${{ secrets.DOCKERHUB_TOKEN }}" \
              -var="users_api_image=${{ secrets.DOCKERHUB_USERNAME }}/users-service:${TAG}" \
              -var="auth_api_image=${{ secrets.DOCKERHUB_USERNAME }}/auth-service:${TAG}" \
              -var="todos_api_image=${{ secrets.DOCKERHUB_USERNAME }}/todos-service:${TAG}" \
              -var="frontend_image=${{ secrets.DOCKERHUB_USERNAME }}/frontend:${TAG}" \
              -var="log_processor_image=${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:${TAG}" \
              -out=tfplan; then
              echo "✅ Plan completed successfully"
              break
            else
              echo "⚠️ Plan attempt $attempt failed"
              if [[ $attempt -lt 3 ]]; then
                echo "🔓 Attempting to unlock state before retry..."
                terraform force-unlock -force 6f82c0a9-c0fe-881e-7792-0eaab46f44cf 2>/dev/null || true
                sleep 10
              else
                echo "❌ All plan attempts failed"
                exit 1
              fi
            fi
          done
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Show Plan (for review)
        run: |
          echo "🔍 PLAN PREVIEW:"
          terraform show tfplan
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Apply
        if: steps.plan.outcome == 'success' && github.ref == 'refs/heads/master'
        run: |
          echo "🚀 Applying infrastructure changes..."
          terraform apply -input=false -auto-approve tfplan
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Verify State Consistency
        run: |
          echo "🔍 Verifying Terraform state consistency..."
          terraform state list
          echo "✅ Terraform state is consistent and up to date!"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Emergency State Unlock
        if: failure()
        continue-on-error: true
        run: |
          echo "🚨 Emergency unlock due to job failure..."
          # Force unlock with all known patterns
          terraform force-unlock -force 6f82c0a9-c0fe-881e-7792-0eaab46f44cf 2>/dev/null || true
          # Try other common lock IDs if they exist
          echo "✅ Emergency unlock completed"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Cleanup
        if: always()
        run: rm -f tfplan
        working-directory: ./terraform

  # Job para notificaciones
  notify-deployment:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [build-production-images, deploy-infrastructure]
    if: always()

    steps:
      - name: Notify Success
        if: needs.deploy-infrastructure.result == 'success'
        run: |
          TAG=${{ needs.build-production-images.outputs.image_tag }}
          echo "✅ Production deployment completed successfully!"
          echo "🚀 Services are now running in production"
          echo "🔗 Images deployed with tag: $TAG"
          echo "🔗 Users API: ${{ secrets.DOCKERHUB_USERNAME }}/users-service:$TAG"
          echo "🔗 Auth API: ${{ secrets.DOCKERHUB_USERNAME }}/auth-service:$TAG"
          echo "🔗 Todos API: ${{ secrets.DOCKERHUB_USERNAME }}/todos-service:$TAG"
          echo "🔗 Frontend: ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$TAG"
          echo "🔗 Log Processor: ${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:$TAG"
          echo "📝 Terraform state is synchronized and up to date"

      - name: Notify Failure
        if: needs.deploy-infrastructure.result == 'failure'
        run: |
          echo "❌ Production deployment failed!"
          echo "🔍 Check the logs for more details"
          exit 1
