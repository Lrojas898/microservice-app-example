name: Production Deployment Pipeline


on:
  push:
    branches: [master]
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging
      resource_group:
        description: "Resource group to deploy to"
        required: true
        default: "pipeline-microservice-app-rg"
        type: choice
        options:
          - microservice-app-pipeline-rg
          - pipeline-microservice-app-rg

env:
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  # Variables de entorno para Terraform con backend azurerm
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  # Dynamic resource group selection based on input or default for push events
  PIPELINE_RESOURCE_GROUP: ${{ github.event.inputs.resource_group || 'pipeline-microservice-app-rg' }}

jobs:
  # Job para validar cÃ³digo antes del despliegue
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            }

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Terraform Format Check
        run: terraform fmt -check -recursive
        working-directory: ./terraform

      - name: Terraform Init
        run: |
          echo "ğŸ”‘ Initializing Terraform with remote backend for validation..."
          # Use specific backend configuration for pipeline resource group
          if [ "${{ env.PIPELINE_RESOURCE_GROUP }}" = "pipeline-microservice-app-rg" ]; then
            echo "ğŸ“ Using new pipeline-specific backend configuration"
            terraform init -upgrade -backend-config=backend-pipeline-new.conf
          elif [ "${{ env.PIPELINE_RESOURCE_GROUP }}" = "microservice-app-pipeline-rg" ]; then
            echo "ğŸ“ Using original pipeline backend configuration"
            terraform init -upgrade -backend-config=backend-pipeline.conf
          else
            echo "ğŸ“ Using default backend configuration"
            terraform init -upgrade
          fi
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Validate
        run: terraform validate
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

  # Job para construir imÃ¡genes Docker para producciÃ³n
  build-production-images:
    name: Build Production Images
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: pre-deployment-checks
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Generate unique image tag
        id: tag
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            TAG="latest"
          else
            TAG="gh-${GITHUB_SHA::8}"
          fi
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Generated tag: $TAG"

      # Set up JDK 8 for Java projects
      - name: Set up JDK 8
        uses: actions/setup-java@v3
        with:
          java-version: "8"
          distribution: "temurin"

      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('users-api/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      # Build users-api (Java/Spring Boot)
      - name: Build users-api
        run: |
          cd ./users-api
          mvn clean package -DskipTests
          cd ..
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/users-service:$TAG ./users-api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/users-service:$TAG

      # Build auth-api (Go)
      - name: Build auth-api
        run: |
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/auth-service:$TAG ./auth-api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/auth-service:$TAG

      # Build todos-api (Node.js)
      - name: Build todos-api
        run: |
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/todos-service:$TAG ./todos-api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/todos-service:$TAG

      # Build frontend (Vue.js) - using pre-built folder
      - name: Build frontend
        run: |
          echo "âš ï¸ Using pre-built 'build' folder from repo"
          if [ ! -d "frontend/build" ]; then
            echo "âŒ Pre-built folder 'build' not found in ./frontend/"
            ls -la frontend/
            exit 1
          fi
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$TAG ./frontend
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$TAG

      # Build log-message-processor (Python)
      - name: Build log-message-processor
        run: |
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:$TAG ./log-message-processor
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:$TAG

  # Job para desplegar infraestructura de producciÃ³n usando App Services (fased deployment)
  deploy-infrastructure:
    name: Deploy Production Infrastructure (App Services)
    runs-on: ubuntu-latest
    timeout-minutes: 90
    needs: [pre-deployment-checks, build-production-images]
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            }

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Terraform Init
        run: |
          echo "ğŸ”‘ Initializing Terraform with remote backend..."
          # Use specific backend configuration for pipeline resource group
          if [ "${{ env.PIPELINE_RESOURCE_GROUP }}" = "pipeline-microservice-app-rg" ]; then
            echo "ğŸ“ Using new pipeline-specific backend configuration for deployment"
            echo "ğŸ“‚ Backend state file: pipeline-new.terraform.tfstate"
            terraform init -upgrade -backend-config=backend-pipeline-new.conf
          elif [ "${{ env.PIPELINE_RESOURCE_GROUP }}" = "microservice-app-pipeline-rg" ]; then
            echo "ğŸ“ Using original pipeline backend configuration for deployment"
            echo "ğŸ“‚ Backend state file: pipeline.terraform.tfstate"
            terraform init -upgrade -backend-config=backend-pipeline.conf
          else
            echo "ğŸ“ Using default backend configuration for deployment"
            echo "ğŸ“‚ Backend state file: prod.terraform.tfstate"
            terraform init -upgrade
          fi
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Check Infrastructure State
        run: |
          echo "ğŸ” Checking current infrastructure state..."

          # Check if state file exists and has content
          state_count=$(terraform state list 2>/dev/null | wc -l || echo "0")

          if [ "$state_count" -eq 0 ]; then
            echo "ğŸ“ Terraform state is empty - fresh deployment mode"
            echo "ğŸš€ Will create all infrastructure from scratch"
            echo "deployment_mode=fresh" >> $GITHUB_ENV
          else
            echo "ğŸ“‹ Found $state_count resources in state - update mode"
            echo "ğŸ”„ Will update existing infrastructure"
            echo "deployment_mode=update" >> $GITHUB_ENV
            terraform state list
          fi
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Import Existing Resources (Smart Sync for App Services)
        run: |
          if [ "${{ env.deployment_mode }}" = "fresh" ]; then
            echo "ğŸš€ Fresh deployment detected - skipping import phase"
            echo "â„¹ï¸ All resources will be created from scratch"
            exit 0
          fi

          echo "ğŸ” Checking for existing Azure resources to import..."

          # Get unique suffix from terraform or generate new one
          UNIQUE_SUFFIX=$(terraform output -raw unique_suffix 2>/dev/null || echo "uni29zdq")
          echo "ğŸ”‘ Using unique suffix: $UNIQUE_SUFFIX"

          # Function to safely import if resource exists in Azure
          safe_import() {
            local resource_name="$1"
            local resource_id="$2"

            echo "ğŸ” Checking if $resource_name exists in Azure..."

            # Check if already in state
            if terraform state show "$resource_name" >/dev/null 2>&1; then
              echo "âœ“ $resource_name already in terraform state"
              return 0
            fi

            # Try to import
            if terraform import "$resource_name" "$resource_id" 2>/dev/null; then
              echo "âœ… Successfully imported $resource_name"
              return 0
            else
              echo "â„¹ï¸ $resource_name not found in Azure (will be created)"
              return 1
            fi
          }

          echo "ğŸš€ Starting smart resource import for App Services architecture..."

          # Core infrastructure (using pipeline-specific resource group)
          safe_import "azurerm_resource_group.main" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}"
          safe_import "module.network.azurerm_virtual_network.main" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Network/virtualNetworks/microservice-vnet"

          # Network subnets
          safe_import "module.network.azurerm_subnet.auth" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Network/virtualNetworks/microservice-vnet/subnets/auth-db-subnet"
          safe_import "module.network.azurerm_subnet.users" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Network/virtualNetworks/microservice-vnet/subnets/users-db-subnet"
          safe_import "module.network.azurerm_subnet.todos" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Network/virtualNetworks/microservice-vnet/subnets/todos-db-subnet"
          safe_import "module.network.azurerm_subnet.cache" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Network/virtualNetworks/microservice-vnet/subnets/cache-subnet"

          # Redis resources
          safe_import "module.security.azurerm_redis_cache.main" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Cache/Redis/microservice-redis-optimized-${UNIQUE_SUFFIX}"
          safe_import "module.security.azurerm_redis_firewall_rule.allow_all" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Cache/Redis/microservice-redis-optimized-${UNIQUE_SUFFIX}/firewallRules/allow_all_ips"

          # Database resources
          safe_import "azurerm_postgresql_flexible_server.consolidated" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}"
          safe_import "azurerm_postgresql_flexible_server_database.auth_db" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}/databases/authdb"
          safe_import "azurerm_postgresql_flexible_server_database.users_db" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}/databases/usersdb"
          safe_import "azurerm_postgresql_flexible_server_database.todos_db" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}/databases/todosdb"

          # App Service Plan and Web Apps (NEW - replacing Container Groups)
          safe_import "azurerm_service_plan.main" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Web/serverFarms/microservice-plan-${UNIQUE_SUFFIX}"
          safe_import "azurerm_linux_web_app.auth" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Web/sites/auth-service-${UNIQUE_SUFFIX}"
          safe_import "azurerm_linux_web_app.users" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Web/sites/users-service-${UNIQUE_SUFFIX}"
          safe_import "azurerm_linux_web_app.todos" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Web/sites/todos-service-${UNIQUE_SUFFIX}"
          safe_import "azurerm_linux_web_app.frontend" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Web/sites/frontend-service-${UNIQUE_SUFFIX}"
          safe_import "azurerm_linux_web_app.log_processor" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.PIPELINE_RESOURCE_GROUP }}/providers/Microsoft.Web/sites/log-processor-service-${UNIQUE_SUFFIX}"

          echo "â„¹ï¸ Skipping legacy Container Groups (replaced by App Services)"
          echo "ğŸ“Š Final state after import:"
          terraform state list | sort
          echo "âœ… Smart import completed for App Services architecture!"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          TF_VAR_dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          TF_VAR_dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Phase 1 - Deploy Core Infrastructure (Service Plan + Databases)
        run: |
          echo "ğŸ—ï¸ Phase 1: Deploying core infrastructure..."
          TAG=${{ needs.build-production-images.outputs.image_tag }}

          terraform apply \
            -target=azurerm_service_plan.main \
            -target=azurerm_postgresql_flexible_server.consolidated \
            -target=module.security.azurerm_redis_cache.main \
            -var="location=chilecentral" \
            -var="resource_group_location=chilecentral" \
            -var="db_location=chilecentral" \
            -var="resource_group_name=${{ env.PIPELINE_RESOURCE_GROUP }}" \
            -var="dockerhub_username=${{ secrets.DOCKERHUB_USERNAME }}" \
            -var="dockerhub_token=${{ secrets.DOCKERHUB_TOKEN }}" \
            -var="users_api_image=${{ secrets.DOCKERHUB_USERNAME }}/users-service:${TAG}" \
            -var="auth_api_image=${{ secrets.DOCKERHUB_USERNAME }}/auth-service:${TAG}" \
            -var="todos_api_image=${{ secrets.DOCKERHUB_USERNAME }}/todos-service:${TAG}" \
            -var="frontend_image=${{ secrets.DOCKERHUB_USERNAME }}/frontend:${TAG}" \
            -var="log_processor_image=${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:${TAG}" \
            -auto-approve
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Phase 2 - Deploy Backend Services (Auth, Users, Todos)
        run: |
          echo "ğŸ”’ Phase 2: Deploying backend services..."
          TAG=${{ needs.build-production-images.outputs.image_tag }}

          terraform apply \
            -target=azurerm_linux_web_app.auth \
            -target=azurerm_linux_web_app.users \
            -target=azurerm_linux_web_app.todos \
            -target=azurerm_linux_web_app.log_processor \
            -var="location=chilecentral" \
            -var="resource_group_location=chilecentral" \
            -var="db_location=chilecentral" \
            -var="resource_group_name=${{ env.PIPELINE_RESOURCE_GROUP }}" \
            -var="dockerhub_username=${{ secrets.DOCKERHUB_USERNAME }}" \
            -var="dockerhub_token=${{ secrets.DOCKERHUB_TOKEN }}" \
            -var="users_api_image=${{ secrets.DOCKERHUB_USERNAME }}/users-service:${TAG}" \
            -var="auth_api_image=${{ secrets.DOCKERHUB_USERNAME }}/auth-service:${TAG}" \
            -var="todos_api_image=${{ secrets.DOCKERHUB_USERNAME }}/todos-service:${TAG}" \
            -var="frontend_image=${{ secrets.DOCKERHUB_USERNAME }}/frontend:${TAG}" \
            -var="log_processor_image=${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:${TAG}" \
            -auto-approve
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Phase 3 - Deploy Frontend (with static proxy URLs)
        run: |
          echo "ğŸŒ Phase 3: Deploying frontend with corrected nginx configuration..."
          TAG=${{ needs.build-production-images.outputs.image_tag }}

          terraform apply \
            -target=azurerm_linux_web_app.frontend \
            -var="location=chilecentral" \
            -var="resource_group_location=chilecentral" \
            -var="db_location=chilecentral" \
            -var="resource_group_name=${{ env.PIPELINE_RESOURCE_GROUP }}" \
            -var="dockerhub_username=${{ secrets.DOCKERHUB_USERNAME }}" \
            -var="dockerhub_token=${{ secrets.DOCKERHUB_TOKEN }}" \
            -var="users_api_image=${{ secrets.DOCKERHUB_USERNAME }}/users-service:${TAG}" \
            -var="auth_api_image=${{ secrets.DOCKERHUB_USERNAME }}/auth-service:${TAG}" \
            -var="todos_api_image=${{ secrets.DOCKERHUB_USERNAME }}/todos-service:${TAG}" \
            -var="frontend_image=${{ secrets.DOCKERHUB_USERNAME }}/frontend:${TAG}" \
            -var="log_processor_image=${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:${TAG}" \
            -auto-approve
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Final Apply - Ensure Complete Deployment
        run: |
          echo "âœ… Final phase: Ensuring all resources are deployed and synchronized..."
          TAG=${{ needs.build-production-images.outputs.image_tag }}

          terraform apply \
            -var="location=chilecentral" \
            -var="resource_group_location=chilecentral" \
            -var="db_location=chilecentral" \
            -var="resource_group_name=${{ env.PIPELINE_RESOURCE_GROUP }}" \
            -var="dockerhub_username=${{ secrets.DOCKERHUB_USERNAME }}" \
            -var="dockerhub_token=${{ secrets.DOCKERHUB_TOKEN }}" \
            -var="users_api_image=${{ secrets.DOCKERHUB_USERNAME }}/users-service:${TAG}" \
            -var="auth_api_image=${{ secrets.DOCKERHUB_USERNAME }}/auth-service:${TAG}" \
            -var="todos_api_image=${{ secrets.DOCKERHUB_USERNAME }}/todos-service:${TAG}" \
            -var="frontend_image=${{ secrets.DOCKERHUB_USERNAME }}/frontend:${TAG}" \
            -var="log_processor_image=${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:${TAG}" \
            -auto-approve
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Restart Services to Ensure Fresh Configuration
        run: |
          echo "ğŸ”„ Restarting services to ensure fresh configuration..."

          # Get unique suffix for service names
          UNIQUE_SUFFIX=$(terraform output -raw unique_suffix 2>/dev/null || echo "uni29zdq")

          # Restart all services to ensure they use latest configuration
          az webapp restart --name "auth-service-${UNIQUE_SUFFIX}" --resource-group "${{ env.PIPELINE_RESOURCE_GROUP }}"
          az webapp restart --name "users-service-${UNIQUE_SUFFIX}" --resource-group "${{ env.PIPELINE_RESOURCE_GROUP }}"
          az webapp restart --name "todos-service-${UNIQUE_SUFFIX}" --resource-group "${{ env.PIPELINE_RESOURCE_GROUP }}"
          az webapp restart --name "frontend-service-${UNIQUE_SUFFIX}" --resource-group "${{ env.PIPELINE_RESOURCE_GROUP }}"
          az webapp restart --name "log-processor-service-${UNIQUE_SUFFIX}" --resource-group "${{ env.PIPELINE_RESOURCE_GROUP }}"

          echo "âœ… All services restarted with fresh configuration"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Verify Deployment and Test Functionality
        run: |
          echo "ğŸ§ª Testing deployed services..."

          # Get service URLs from terraform output
          FRONTEND_URL=$(terraform output -raw frontend_url 2>/dev/null || echo "")
          AUTH_URL=$(terraform output -raw auth_service_url 2>/dev/null || echo "")

          if [ -n "$FRONTEND_URL" ] && [ -n "$AUTH_URL" ]; then
            echo "ğŸ”— Frontend URL: $FRONTEND_URL"
            echo "ğŸ”— Auth Service URL: $AUTH_URL"

            # Test auth service directly
            echo "ğŸ” Testing auth service..."
            curl -f "$AUTH_URL/version" || echo "âš ï¸ Auth service version check failed"

            # Test login through frontend proxy (this was the main fix)
            echo "ğŸ” Testing login through frontend proxy..."
            LOGIN_RESPONSE=$(curl -s -X POST "$FRONTEND_URL/login" \
              -H "Content-Type: application/json" \
              -d '{"username":"admin","password":"admin"}' \
              -w "%{http_code}")

            if echo "$LOGIN_RESPONSE" | grep -q "200"; then
              echo "âœ… Login test passed - App Services deployment successful!"
            else
              echo "âš ï¸ Login test failed, but deployment completed"
            fi
          else
            echo "âš ï¸ Could not retrieve service URLs for testing"
          fi
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Verify State Consistency
        run: |
          echo "ğŸ” Verifying Terraform state consistency..."
          terraform state list | grep -E "(azurerm_service_plan|azurerm_linux_web_app)" | sort
          echo "âœ… App Services deployment verified!"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Cleanup
        if: always()
        run: rm -f tfplan
        working-directory: ./terraform

  # Job para notificaciones
  notify-deployment:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [build-production-images, deploy-infrastructure]
    if: always()

    steps:
      - name: Notify Success
        if: needs.deploy-infrastructure.result == 'success'
        run: |
          TAG=${{ needs.build-production-images.outputs.image_tag }}
          echo "âœ… Production deployment completed successfully!"
          echo "ğŸš€ App Services are now running in production (Chile Central)"
          echo "ğŸ”— Images deployed with tag: $TAG"
          echo ""
          echo "ğŸ“¦ Deployed Services:"
          echo "ğŸ”— Users Service: ${{ secrets.DOCKERHUB_USERNAME }}/users-service:$TAG"
          echo "ğŸ”— Auth Service: ${{ secrets.DOCKERHUB_USERNAME }}/auth-service:$TAG"
          echo "ğŸ”— Todos Service: ${{ secrets.DOCKERHUB_USERNAME }}/todos-service:$TAG"
          echo "ğŸ”— Frontend: ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$TAG"
          echo "ğŸ”— Log Processor: ${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:$TAG"
          echo ""
          echo "ğŸ—ï¸ Infrastructure:"
          echo "âœ… Azure App Service Plan (B1 SKU)"
          echo "âœ… 5 Linux Web Apps with Docker containers"
          echo "âœ… PostgreSQL Flexible Server (consolidated)"
          echo "âœ… Redis Cache Basic (public access)"
          echo "âœ… Virtual Network with subnets"
          echo ""
          echo "ğŸ”§ Key Improvements Applied:"
          echo "âœ… Replaced Container Groups with App Services (faster deployment)"
          echo "âœ… Fixed nginx proxy configuration with static URLs"
          echo "âœ… Corrected JWT_SECRET configuration"
          echo "âœ… Implemented phased deployment strategy"
          echo "âœ… Added service restart automation"
          echo ""
          echo "ğŸ“ Terraform state is synchronized and up to date"
          echo "ğŸŒ Application ready for use!"

      - name: Notify Failure
        if: needs.deploy-infrastructure.result == 'failure'
        run: |
          echo "âŒ Production deployment failed!"
          echo "ğŸ” Check the logs for more details"
          exit 1
