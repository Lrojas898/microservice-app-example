name: Production Deployment Pipeline

on:
  push:
    branches: [master]
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

env:
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  # Variables de entorno para Terraform con backend azurerm
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

jobs:
  # Job para validar c√≥digo antes del despliegue
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            }

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Terraform Format Check
        run: terraform fmt -check -recursive
        working-directory: ./terraform

      - name: Terraform Init
        run: |
          echo "üîë Initializing Terraform with remote backend for validation..."
          terraform init -upgrade
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Validate
        run: terraform validate
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

  # Job para construir im√°genes Docker para producci√≥n
  build-production-images:
    name: Build Production Images
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: pre-deployment-checks
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Generate unique image tag
        id: tag
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            TAG="latest"
          else
            TAG="gh-${GITHUB_SHA::8}"
          fi
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT
          echo "üì¶ Generated tag: $TAG"

      # Set up JDK 8 for Java projects
      - name: Set up JDK 8
        uses: actions/setup-java@v3
        with:
          java-version: "8"
          distribution: "temurin"

      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('users-api/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      # Build users-api (Java/Spring Boot)
      - name: Build users-api
        run: |
          cd ./users-api
          mvn clean package -DskipTests
          cd ..
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/users-service:$TAG ./users-api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/users-service:$TAG

      # Build auth-api (Go)
      - name: Build auth-api
        run: |
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/auth-service:$TAG ./auth-api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/auth-service:$TAG

      # Build todos-api (Node.js)
      - name: Build todos-api
        run: |
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/todos-service:$TAG ./todos-api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/todos-service:$TAG

      # Build frontend (Vue.js) - using pre-built folder
      - name: Build frontend
        run: |
          echo "‚ö†Ô∏è Using pre-built 'build' folder from repo"
          if [ ! -d "frontend/build" ]; then
            echo "‚ùå Pre-built folder 'build' not found in ./frontend/"
            ls -la frontend/
            exit 1
          fi
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$TAG ./frontend
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$TAG

      # Build log-message-processor (Python)
      - name: Build log-message-processor
        run: |
          TAG=${{ steps.tag.outputs.image_tag }}
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:$TAG ./log-message-processor
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:$TAG

  # Job para desplegar infraestructura de producci√≥n
  deploy-infrastructure:
    name: Deploy Production Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: [pre-deployment-checks, build-production-images]
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            }

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Terraform Init
        run: |
          echo "üîë Initializing Terraform with remote backend..."
          terraform init -upgrade
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Check Infrastructure State
        run: |
          echo "üîç Checking current infrastructure state..."

          # Check if state file exists and has content
          state_count=$(terraform state list 2>/dev/null | wc -l || echo "0")

          if [ "$state_count" -eq 0 ]; then
            echo "üìù Terraform state is empty - fresh deployment mode"
            echo "üöÄ Will create all infrastructure from scratch"
            echo "deployment_mode=fresh" >> $GITHUB_ENV
          else
            echo "üìã Found $state_count resources in state - update mode"
            echo "üîÑ Will update existing infrastructure"
            echo "deployment_mode=update" >> $GITHUB_ENV
            terraform state list
          fi
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Import Existing Resources (Smart Sync)
        run: |
          echo "üîç Checking for existing Azure resources to import..."

          # Get unique suffix from terraform or generate new one
          UNIQUE_SUFFIX=$(terraform output -raw unique_suffix 2>/dev/null || echo "13ef44lc")
          echo "üîë Using unique suffix: $UNIQUE_SUFFIX"

          # Function to safely import if resource exists in Azure
          safe_import() {
            local resource_name="$1"
            local resource_id="$2"

            echo "üîç Checking if $resource_name exists in Azure..."

            # Check if already in state
            if terraform state show "$resource_name" >/dev/null 2>&1; then
              echo "‚úì $resource_name already in terraform state"
              return 0
            fi

            # Try to import
            if terraform import "$resource_name" "$resource_id" 2>/dev/null; then
              echo "‚úÖ Successfully imported $resource_name"
              return 0
            else
              echo "‚ÑπÔ∏è $resource_name not found in Azure (will be created)"
              return 1
            fi
          }

          echo "üöÄ Starting smart resource import..."

          # Core infrastructure
          safe_import "azurerm_resource_group.main" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg"
          safe_import "module.network.azurerm_virtual_network.main" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Network/virtualNetworks/microservice-vnet"

          # Network subnets
          safe_import "module.network.azurerm_subnet.auth" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Network/virtualNetworks/microservice-vnet/subnets/auth-db-subnet"
          safe_import "module.network.azurerm_subnet.users" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Network/virtualNetworks/microservice-vnet/subnets/users-db-subnet"
          safe_import "module.network.azurerm_subnet.todos" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Network/virtualNetworks/microservice-vnet/subnets/todos-db-subnet"
          safe_import "module.network.azurerm_subnet.cache" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Network/virtualNetworks/microservice-vnet/subnets/cache-subnet"

          # Redis resources (likely exist based on error log)
          safe_import "module.security.azurerm_redis_cache.main" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Cache/Redis/microservice-redis-optimized-${UNIQUE_SUFFIX}"
          safe_import "module.security.azurerm_redis_firewall_rule.allow_all" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Cache/Redis/microservice-redis-optimized-${UNIQUE_SUFFIX}/firewallRules/allow_all_ips"

          # Database resources
          safe_import "azurerm_postgresql_flexible_server.consolidated" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}"
          safe_import "azurerm_postgresql_flexible_server_database.auth_db" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}/databases/authdb"
          safe_import "azurerm_postgresql_flexible_server_database.users_db" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}/databases/usersdb"
          safe_import "azurerm_postgresql_flexible_server_database.todos_db" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.DBforPostgreSQL/flexibleServers/microservice-db-server-${UNIQUE_SUFFIX}/databases/todosdb"

          # Application Insights
          safe_import "azurerm_logic_app_workflow.log_processor" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.Logic/workflows/log_processor"

          # Container Groups (likely don't exist due to the error)
          for container in zipkin auth users todos log_processor frontend; do
            container_name="${container//_/-}-service"
            safe_import "azurerm_container_group.$container" "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/microservice-app-rg/providers/Microsoft.ContainerInstance/containerGroups/$container_name"
          done

          echo "üìä Final state after import:"
          terraform state list | sort
          echo "‚úÖ Smart import completed!"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}


      - name: Terraform Plan
        id: plan
        run: |
          echo "üìã Generating execution plan..."
          echo "üîß Deployment mode: ${{ env.deployment_mode }}"
          TAG=${{ needs.build-production-images.outputs.image_tag }}

          terraform plan \
            -var="location=chilecentral" \
            -var="resource_group_location=chilecentral" \
            -var="db_location=chilecentral" \
            -var="subscriptionId=${{ env.AZURE_SUBSCRIPTION_ID }}" \
            -var="client_id=${{ env.AZURE_CLIENT_ID }}" \
            -var="client_secret=${{ env.AZURE_CLIENT_SECRET }}" \
            -var="tenant_id=${{ env.AZURE_TENANT_ID }}" \
            -var="dockerhub_username=${{ secrets.DOCKERHUB_USERNAME }}" \
            -var="dockerhub_token=${{ secrets.DOCKERHUB_TOKEN }}" \
            -var="users_api_image=${{ secrets.DOCKERHUB_USERNAME }}/users-service:${TAG}" \
            -var="auth_api_image=${{ secrets.DOCKERHUB_USERNAME }}/auth-service:${TAG}" \
            -var="todos_api_image=${{ secrets.DOCKERHUB_USERNAME }}/todos-service:${TAG}" \
            -var="frontend_image=${{ secrets.DOCKERHUB_USERNAME }}/frontend:${TAG}" \
            -var="log_processor_image=${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:${TAG}" \
            -out=tfplan
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Show Plan (for review)
        run: |
          echo "üîç PLAN PREVIEW:"
          terraform show tfplan
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Apply
        if: steps.plan.outcome == 'success' && github.ref == 'refs/heads/master'
        run: |
          echo "üöÄ Applying infrastructure changes..."
          terraform apply -input=false -auto-approve tfplan
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Verify State Consistency
        run: |
          echo "üîç Verifying Terraform state consistency..."
          terraform state list
          echo "‚úÖ Terraform state is consistent and up to date!"
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}


      - name: Cleanup
        if: always()
        run: rm -f tfplan
        working-directory: ./terraform

  # Job para notificaciones
  notify-deployment:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [build-production-images, deploy-infrastructure]
    if: always()

    steps:
      - name: Notify Success
        if: needs.deploy-infrastructure.result == 'success'
        run: |
          TAG=${{ needs.build-production-images.outputs.image_tag }}
          echo "‚úÖ Production deployment completed successfully!"
          echo "üöÄ Services are now running in production"
          echo "üîó Images deployed with tag: $TAG"
          echo "üîó Users API: ${{ secrets.DOCKERHUB_USERNAME }}/users-service:$TAG"
          echo "üîó Auth API: ${{ secrets.DOCKERHUB_USERNAME }}/auth-service:$TAG"
          echo "üîó Todos API: ${{ secrets.DOCKERHUB_USERNAME }}/todos-service:$TAG"
          echo "üîó Frontend: ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$TAG"
          echo "üîó Log Processor: ${{ secrets.DOCKERHUB_USERNAME }}/log-message-processor:$TAG"
          echo "üìù Terraform state is synchronized and up to date"

      - name: Notify Failure
        if: needs.deploy-infrastructure.result == 'failure'
        run: |
          echo "‚ùå Production deployment failed!"
          echo "üîç Check the logs for more details"
          exit 1
